#include <command.h>
#include <vga.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <arch/i386/pit.h>
#include <vmm.h>
#include <arch/i386/paging.h>
#include <pmm.h>
#include <stdint.h>
#include <stddef.h>
#include <version.h>
#include <syscall.h>
#include <fs/vfs.h>
#include <fs/simplefs.h>
#include <dev/ata.h>
#include <user.h>
#include <fs_layout.h>
#include <serial.h>
#include <shell.h>
#include <process.h>
#include <ipc.h>
#include <partition.h>
#include <envars.h>
#include <kmodule.h>

// Forward declarations for kprint (defined in kernel.c)
extern void kprint(const char *str);
extern uint32_t total_memory_kb;
extern volatile uint32_t system_ticks;

// Forward declarations for command registry
static const command_t commands[];
static const uint32_t num_commands;

// Command handlers
static void cmd_help(const char* args) {
    (void)args; // Unused
    kprint("Available Commands:");
    
    for (uint32_t i = 0; i < num_commands; i++) {
        // Print command name and syntax
        vga_puts("  ");
        vga_puts(commands[i].name);
        if (commands[i].syntax && commands[i].syntax[0] != '\0') {
            vga_puts(" ");
            vga_puts(commands[i].syntax);
        }
        kprint("");
        
        // Print description with indentation
        vga_puts("    ");
        kprint(commands[i].description);
    }
}

static void cmd_mem(const char* args) {
    (void)args; // Unused
    char buf[32];
    if (total_memory_kb > 0) {
        vga_puts("Total Memory: "); itoa(total_memory_kb / 1024, buf, 10); vga_puts(buf); vga_puts(" MB (");
        itoa(total_memory_kb, buf, 10); vga_puts(buf); kprint(" KB)");
    } else {
        kprint("Memory information not available.");
    }
}

static void cmd_clear(const char* args) {
    (void)args; // Unused
    vga_clear();
}

static void cmd_version(const char* args) {
    (void)args; // Unused
    kprint(AOS_VERSION);
}

static void cmd_reboot(const char* args) {
    (void)args; // Unused
    kprint("Rebooting...");
    outb(0x64, 0xFE);
    while(1) { asm volatile("cli; hlt"); }
}

static void cmd_halt(const char* args) {
    (void)args; // Unused
    kprint("System Halted.");
    asm volatile("cli; hlt");
}

static void cmd_poweroff(const char* args) {
    (void)args; // Unused
    kprint("Powering off (QEMU)...");
    outw(0x604, 0x2000); // QEMU common
    kprint("If not on a supported hypervisor or this fails, use 'halt'.");
}

static void cmd_echo(const char* args) {
    if (args && *args) {
        kprint(args);
    } else {
        kprint("");
    }
}

static void cmd_uptime(const char* args) {
    (void)args; // Unused
    char buf[64];
    uint32_t current_ticks = system_ticks;
    uint32_t pit_freq_hz = (PIT_DEFAULT_DIVISOR == 0) ? (PIT_BASE_FREQUENCY / 65536) : (PIT_BASE_FREQUENCY / PIT_DEFAULT_DIVISOR);
    uint32_t total_seconds = current_ticks / pit_freq_hz;
    uint32_t hours = total_seconds / 3600;
    uint32_t remainder_seconds = total_seconds % 3600;
    uint32_t minutes = remainder_seconds / 60;
    uint32_t seconds = remainder_seconds % 60;
    vga_puts("System Uptime: ");
    itoa(hours, buf, 10); vga_puts(buf); vga_puts("h ");
    itoa(minutes, buf, 10); vga_puts(buf); vga_puts("m ");
    itoa(seconds, buf, 10); vga_puts(buf); vga_puts("s (Total Ticks: ");
    itoa(current_ticks, buf, 10); vga_puts(buf); kprint(")");
}

static void cmd_vmm(const char* args) {
    (void)args; // Unused
    kprint("Virtual Memory Manager Status:");
    if (kernel_address_space) {
        vmm_print_stats(kernel_address_space);
        kprint("Paging enabled: Yes");
        vga_puts("Current page directory: 0x");
        char buf[12];
        itoa(current_directory->physical_addr, buf, 10);
        kprint(buf);
    } else {
        kprint("VMM not initialized");
    }
}

/* static void cmd_test_alloc(const char* args) {
    (void)args; // Unused
    kprint("Testing memory allocation...\n");
    void *ptr1 = kmalloc(1024);
    void *ptr2 = kmalloc(4096);
    void *ptr3 = kmalloc_pages(2);
    
    char buf[12];
    kprint("Allocated 1KB at: 0x"); itoa((uint32_t)ptr1, buf, 10); kprint(buf); kprint("\n");
    kprint("Allocated 4KB at: 0x"); itoa((uint32_t)ptr2, buf, 10); kprint(buf); kprint("\n");
    kprint("Allocated 2 pages at: 0x"); itoa((uint32_t)ptr3, buf, 10); kprint(buf); kprint("\n");
    
    // Test virtual to physical translation
    if (ptr1) {
        uint32_t phys = vmm_virt_to_phys(kernel_address_space, (uint32_t)ptr1);
        kprint("Virtual 0x"); itoa((uint32_t)ptr1, buf, 10); kprint(buf);
        kprint(" -> Physical 0x"); itoa(phys, buf, 10); kprint(buf); kprint("\n");
    }
    
    if (ptr1 && ptr2 && ptr3) {
        kprint("Memory allocation test passed!\n");
    } else {
        kprint("Memory allocation test failed!\n");
    }
} */

static void cmd_test_page(const char* args) {
    (void)args; // Unused
    kprint("Testing page allocation...");
    void *page1 = alloc_page();
    void *page2 = alloc_page();
    
    char buf[12];
    vga_puts("Physical page 1: 0x"); itoa((uint32_t)page1, buf, 10); kprint(buf);
    vga_puts("Physical page 2: 0x"); itoa((uint32_t)page2, buf, 10); kprint(buf);
    
    if (page1 && page2) {
        kprint("Page allocation test passed!");
        free_page(page1);
        free_page(page2);
        kprint("Pages freed.");
    } else {
        kprint("Page allocation test failed!");
    }
}

static void cmd_test_fs(const char* args) {
    (void)args; // Unused
    char buf[32];
    
    kprint("Testing VFS with ramfs...");
    kprint("");
    
    // Test 1: Create a directory
    kprint("Creating directory /test...");
    int ret = sys_mkdir("/test");
    if (ret == VFS_OK) {
        kprint("  [OK] Directory created");
    } else {
        vga_puts("  [FAIL] Error: "); itoa(ret, buf, 10); kprint(buf);
        return;
    }
    
    // Test 2: Create and write to a file
    kprint("Creating file /test/hello.txt...");
    int fd = sys_open("/test/hello.txt", O_CREAT | O_WRONLY);
    if (fd >= 0) {
        vga_puts("  [OK] File opened (fd="); itoa(fd, buf, 10); vga_puts(buf); kprint(")");
        
        const char* test_data = "Hello from aOS filesystem!";
        int bytes = sys_write(fd, test_data, strlen(test_data));
        vga_puts("  [OK] Wrote "); itoa(bytes, buf, 10); vga_puts(buf); kprint(" bytes");
        
        sys_close(fd);
        kprint("  [OK] File closed");
    } else {
        vga_puts("  [FAIL] Error: "); itoa(fd, buf, 10); kprint(buf);
        return;
    }
    
    // Test 3: Read the file back
    kprint("Reading file /test/hello.txt...");
    fd = sys_open("/test/hello.txt", O_RDONLY);
    if (fd >= 0) {
        char read_buf[128] = {0};
        int bytes = sys_read(fd, read_buf, sizeof(read_buf) - 1);
        vga_puts("  [OK] Read "); itoa(bytes, buf, 10); vga_puts(buf); kprint(" bytes");
        vga_puts("  Content: "); kprint(read_buf);
        
        sys_close(fd);
        kprint("  [OK] File closed");
    } else {
        vga_puts("  [FAIL] Error: "); itoa(fd, buf, 10); kprint(buf);
        return;
    }
    
    // Test 4: List root directory
    kprint("Listing root directory /...");
    fd = sys_open("/", O_RDONLY | O_DIRECTORY);
    if (fd >= 0) {
        dirent_t dirent;
        int count = 0;
        while (sys_readdir(fd, &dirent) == VFS_OK) {
            vga_puts("  "); vga_puts(dirent.name);
            vga_puts(" (inode="); itoa(dirent.inode, buf, 10); vga_puts(buf);
            vga_puts(", type="); itoa(dirent.type, buf, 10); vga_puts(buf); kprint(")");
            count++;
        }
        vga_puts("  [OK] Found "); itoa(count, buf, 10); vga_puts(buf); kprint(" entries");
        sys_close(fd);
    } else {
        vga_puts("  [FAIL] Error: "); itoa(fd, buf, 10); kprint(buf);
        return;
    }
    
    kprint("");
    kprint("VFS test completed successfully!");
}

static void cmd_lst(const char* args) {
    char buf[32];
    const char* path = args && *args ? args : ".";  // Use current directory instead of "/"
    
    int fd = sys_open(path, O_RDONLY | O_DIRECTORY);
    if (fd < 0) {
        vga_puts("lst: cannot access '"); vga_puts(path); vga_puts("': ");
        if (fd == VFS_ERR_NOTFOUND) {
            kprint("No such file or directory");
        } else if (fd == VFS_ERR_NOTDIR) {
            kprint("Not a directory");
        } else {
            vga_puts("Error "); itoa(fd, buf, 10); kprint(buf);
        }
        return;
    }
    
    dirent_t dirent;
    int count = 0;
    while (sys_readdir(fd, &dirent) == VFS_OK) {
        vga_puts(dirent.name);
        if (dirent.type == VFS_DIRECTORY) {
            vga_puts("/");
        }
        kprint("");
        count++;
    }
    
    if (count == 0) {
        kprint("(empty directory)");
    }
    
    sys_close(fd);
}

static void cmd_view(const char* args) {
    char buf[32];
    
    if (!args || !*args) {
        kprint("view: missing file operand");
        kprint("Usage: view <filename>");
        return;
    }
    
    int fd = sys_open(args, O_RDONLY);
    if (fd < 0) {
        vga_puts("view: '"); vga_puts(args); vga_puts("': ");
        if (fd == VFS_ERR_NOTFOUND) {
            kprint("No such file or directory");
        } else if (fd == VFS_ERR_ISDIR) {
            kprint("Is a directory");
        } else {
            vga_puts("Error "); itoa(fd, buf, 10); kprint(buf);
        }
        return;
    }
    
    char read_buf[256];
    int bytes;
    while ((bytes = sys_read(fd, read_buf, sizeof(read_buf) - 1)) > 0) {
        read_buf[bytes] = '\0';
        vga_puts(read_buf);
    }
    kprint("");
    
    sys_close(fd);
}

static void cmd_create(const char* args) {
    char buf[32];
    
    if (!args || !*args) {
        kprint("create: missing file operand");
        kprint("Usage: create <filename> [--empty]");
        return;
    }
    
    // Check for --empty flag
    const char* space = args;
    while (*space && *space != ' ') {
        space++;
    }
    
    char filename[256];
    uint32_t name_len;
    int empty_mode = 0;
    
    if (*space != '\0') {
        // Has arguments, check for --empty
        const char* flag = space;
        while (*flag && *flag == ' ') {
            flag++;
        }
        
        if (strcmp(flag, "--empty") == 0) {
            empty_mode = 1;
            name_len = space - args;
        } else {
            name_len = strlen(args);
        }
    } else {
        name_len = strlen(args);
    }
    
    if (name_len >= sizeof(filename)) {
        kprint("create: filename too long");
        return;
    }
    
    for (uint32_t i = 0; i < name_len; i++) {
        filename[i] = args[i];
    }
    filename[name_len] = '\0';
    
    // Try to open existing file first if empty mode
    if (empty_mode) {
        int fd_check = sys_open(filename, O_RDONLY);
        if (fd_check >= 0) {
            sys_close(fd_check);
            vga_puts("Touched: "); kprint(filename);
            return;
        }
    }
    
    int fd = sys_open(filename, O_CREAT | O_WRONLY);
    if (fd < 0) {
        vga_puts("create: cannot create '"); vga_puts(filename); vga_puts("': ");
        if (fd == VFS_ERR_EXISTS) {
            kprint("File already exists");
        } else if (fd == VFS_ERR_NOTFOUND) {
            kprint("Parent directory not found");
        } else if (fd == VFS_ERR_NOSPACE) {
            kprint("No space left");
        } else if (fd == VFS_ERR_IO) {
            kprint("I/O error");
        } else {
            vga_puts("Error code "); 
            // Print as signed integer
            if (fd < 0) {
                vga_putc('-');
                itoa(-fd, buf, 10);
            } else {
                itoa(fd, buf, 10);
            }
            kprint(buf);
        }
        return;
    }
    
    sys_close(fd);
    vga_puts("Created file: "); kprint(filename);
}

static void cmd_write(const char* args) {
    char buf[32];
    
    if (!args || !*args) {
        kprint("write: missing file operand");
        kprint("Usage: write <filename> <content>");
        return;
    }
    
    // Find first space to separate filename from content
    const char* space = args;
    while (*space && *space != ' ') {
        space++;
    }
    
    if (*space == '\0') {
        kprint("write: missing content");
        kprint("Usage: write <filename> <content>");
        return;
    }
    
    // Extract filename
    char filename[256];
    uint32_t name_len = space - args;
    if (name_len >= sizeof(filename)) {
        kprint("write: filename too long");
        return;
    }
    for (uint32_t i = 0; i < name_len; i++) {
        filename[i] = args[i];
    }
    filename[name_len] = '\0';
    
    // Skip spaces to get content
    const char* content = space;
    while (*content && *content == ' ') {
        content++;
    }
    
    if (*content == '\0') {
        kprint("write: missing content");
        return;
    }
    
    // Open file (create if doesn't exist, truncate if exists)
    int fd = sys_open(filename, O_CREAT | O_WRONLY | O_TRUNC);
    if (fd < 0) {
        vga_puts("write: cannot open '"); vga_puts(filename); vga_puts("': ");
        if (fd == VFS_ERR_NOTFOUND) {
            kprint("Parent directory not found");
        } else if (fd == VFS_ERR_ISDIR) {
            kprint("Is a directory");
        } else {
            vga_puts("Error "); itoa(fd, buf, 10); kprint(buf);
        }
        return;
    }
    
    // Write content
    int content_len = strlen(content);
    int bytes = sys_write(fd, content, content_len);
    
    if (bytes < 0) {
        vga_puts("write: write error: "); itoa(bytes, buf, 10); kprint(buf);
    } else {
        vga_puts("Wrote "); itoa(bytes, buf, 10); vga_puts(buf); 
        vga_puts(" bytes to "); kprint(filename);
    }
    
    sys_close(fd);
}

// Helper function to recursively remove directory contents
static int rm_recursive(const char* path) {
    char buf[32];
    
    // Try to get file/directory info
    stat_t file_stat;
    int stat_ret = sys_stat(path, &file_stat);
    
    if (stat_ret != VFS_OK) {
        return stat_ret;
    }
    
    // If it's a file, just unlink it
    if ((file_stat.st_mode & 0xF000) != 0x4000) {
        return sys_unlink(path);
    }
    
    // It's a directory - remove all contents first
    int fd = sys_open(path, O_RDONLY | O_DIRECTORY);
    if (fd < 0) {
        return fd;
    }
    
    dirent_t dirent;
    char child_path[512];
    
    while (sys_readdir(fd, &dirent) == VFS_OK) {
        // Skip . and ..
        if (strcmp(dirent.name, ".") == 0 || strcmp(dirent.name, "..") == 0) {
            continue;
        }
        
        // Build full path to child
        uint32_t path_len = strlen(path);
        uint32_t name_len = strlen(dirent.name);
        
        if (path_len + name_len + 2 > 511) {
            sys_close(fd);
            return VFS_ERR_INVALID;
        }
        
        strcpy(child_path, path);
        if (path_len > 0 && path[path_len - 1] != '/') {
            child_path[path_len] = '/';
            child_path[path_len + 1] = '\0';
        }
        strcat(child_path, dirent.name);
        
        // Recursively remove child
        int ret = rm_recursive(child_path);
        if (ret != VFS_OK) {
            vga_puts("rm: failed to remove '"); vga_puts(child_path); vga_puts("': Error ");
            itoa(ret, buf, 10); kprint(buf);
            sys_close(fd);
            return ret;
        }
    }
    
    sys_close(fd);
    
    // Now remove the empty directory
    return sys_rmdir(path);
}

static void cmd_rm(const char* args) {
    char buf[32];
    
    if (!args || !*args) {
        kprint("rm: missing operand");
        kprint("Usage: rm [--force] <file|directory>");
        return;
    }
    
    // Check for --force flag
    int force = 0;
    const char* path = args;
    
    if (strncmp(args, "--force", 7) == 0) {
        force = 1;
        path = args + 7;
        // Skip spaces after flag
        while (*path && *path == ' ') {
            path++;
        }
        if (*path == '\0') {
            kprint("rm: missing operand after --force");
            kprint("Usage: rm [--force] <file|directory>");
            return;
        }
    }
    
    // Try to get file/directory info first
    stat_t file_stat;
    int stat_ret = sys_stat(path, &file_stat);
    
    if (stat_ret != VFS_OK) {
        vga_puts("rm: cannot access '"); vga_puts(path); vga_puts("': ");
        if (stat_ret == VFS_ERR_NOTFOUND) {
            kprint("No such file or directory");
        } else {
            vga_puts("Error "); itoa(stat_ret, buf, 10); kprint(buf);
        }
        return;
    }
    
    // Use recursive removal if force flag is set
    int ret;
    if (force) {
        ret = rm_recursive(path);
    } else {
        // Determine if it's a file or directory and call appropriate function
        if ((file_stat.st_mode & 0xF000) == 0x4000) { // Directory check (S_IFDIR)
            ret = sys_rmdir(path);
        } else {
            ret = sys_unlink(path);
        }
    }
    
    if (ret == VFS_OK) {
        vga_puts("Removed: "); kprint(path);
    } else {
        vga_puts("rm: cannot remove '"); vga_puts(path); vga_puts("': ");
        if (ret == VFS_ERR_NOTFOUND) {
            kprint("No such file or directory");
        } else if (ret == VFS_ERR_NOTEMPTY) {
            kprint("Directory not empty (use --force to remove recursively)");
        } else if (ret == VFS_ERR_PERM) {
            kprint("Permission denied");
        } else {
            vga_puts("Error "); itoa(ret, buf, 10); kprint(buf);
        }
    }
}

static void cmd_mkfld(const char* args) {
    char buf[32];
    
    if (!args || !*args) {
        kprint("mkfld: missing directory operand");
        kprint("Usage: mkfld <dirname>");
        return;
    }
    
    int ret = sys_mkdir(args);
    if (ret == VFS_OK) {
        vga_puts("Created directory: "); kprint(args);
    } else {
        vga_puts("mkfld: cannot create directory '"); vga_puts(args); vga_puts("': ");
        if (ret == VFS_ERR_EXISTS) {
            kprint("File or directory already exists");
        } else if (ret == VFS_ERR_NOTFOUND) {
            kprint("Parent directory not found");
        } else if (ret == VFS_ERR_NOSPACE) {
            kprint("No space left");
        } else {
            vga_puts("Error "); itoa(ret, buf, 10); kprint(buf);
        }
    }
}

static void cmd_go(const char* args) {
    char buf[32];
    
    if (!args || !*args) {
        kprint("go: missing directory operand");
        kprint("Usage: go <directory>");
        return;
    }
    
    // Security check: Non-admin users cannot leave their home directory
    if (!user_is_admin()) {
        session_t* session = user_get_session();
        if (!session || !session->user) {
            kprint("Error: Not logged in");
            return;
        }
        
        // Normalize the target path to get absolute path
        char* resolved_path = vfs_normalize_path(args);
        if (!resolved_path) {
            vga_set_color(0x0C); // Light red
            vga_puts("go: Failed to resolve path\n");
            vga_set_color(0x0F); // White
            return;
        }
        
        // Check if the resolved path is within the user's home directory
        const char* home_dir = session->user->home_dir;
        uint32_t home_len = strlen(home_dir);
        
        // Path must start with home directory
        int is_within_home = 0;
        if (strcmp(resolved_path, home_dir) == 0) {
            // Exactly the home directory
            is_within_home = 1;
        } else if (strncmp(resolved_path, home_dir, home_len) == 0) {
            // Check that it's actually a subdirectory (next char must be '/')
            if (resolved_path[home_len] == '/') {
                is_within_home = 1;
            }
        }
        
        if (!is_within_home) {
            vga_set_color(0x0C); // Light red
            vga_puts("go: Permission denied - non-admin users cannot leave home directory\n");
            vga_set_color(0x0F); // White
            kfree(resolved_path);
            return;
        }
        
        kfree(resolved_path);
    }
    
    int ret = vfs_chdir(args);
    if (ret == VFS_OK) {
        const char* cwd = vfs_getcwd();
        vga_puts("Changed directory to: ");
        kprint(cwd ? cwd : "/");
    } else {
        vga_puts("go: cannot change directory to '"); vga_puts(args); vga_puts("': ");
        if (ret == VFS_ERR_NOTFOUND) {
            kprint("No such file or directory");
        } else if (ret == VFS_ERR_NOTDIR) {
            kprint("Not a directory");
        } else {
            vga_puts("Error "); itoa(ret, buf, 10); kprint(buf);
        }
    }
}

static void cmd_pwd(const char* args) {
    (void)args; // Unused
    const char* cwd = vfs_getcwd();
    kprint(cwd ? cwd : "/");
}

static void cmd_disk_info(const char* args) {
    (void)args; // Unused
    char buf[32];
    
    if (ata_drive_available()) {
        kprint("ATA Drive Status: Available");
        kprint("Disk operations: Enabled");
        kprint("Filesystem: SimpleFS (if mounted)");
        kprint("");
        
        // Get filesystem stats
        simplefs_superblock_t stats;
        if (simplefs_get_stats(&stats) == 0) {
            kprint("=== SimpleFS Statistics ===");
            
            vga_puts("Total Blocks: ");
            itoa(stats.total_blocks, buf, 10);
            kprint(buf);
            
            vga_puts("Free Blocks: ");
            itoa(stats.free_blocks, buf, 10);
            kprint(buf);
            
            vga_puts("Used Blocks: ");
            itoa(stats.total_blocks - stats.free_blocks, buf, 10);
            kprint(buf);
            
            vga_puts("Total Inodes: ");
            itoa(stats.total_inodes, buf, 10);
            kprint(buf);
            
            vga_puts("Free Inodes: ");
            itoa(stats.free_inodes, buf, 10);
            kprint(buf);
            
            vga_puts("Used Inodes: ");
            itoa(stats.total_inodes - stats.free_inodes, buf, 10);
            kprint(buf);
            
            uint32_t total_mb = (stats.total_blocks * stats.block_size) / (1024 * 1024);
            uint32_t used_mb = ((stats.total_blocks - stats.free_blocks) * stats.block_size) / (1024 * 1024);
            uint32_t free_mb = (stats.free_blocks * stats.block_size) / (1024 * 1024);
            
            vga_puts("Total Size: ");
            itoa(total_mb, buf, 10);
            vga_puts(buf);
            kprint(" MB");
            
            vga_puts("Used Space: ");
            itoa(used_mb, buf, 10);
            vga_puts(buf);
            kprint(" MB");
            
            vga_puts("Free Space: ");
            itoa(free_mb, buf, 10);
            vga_puts(buf);
            kprint(" MB");
        } else {
            kprint("Could not retrieve filesystem statistics");
        }
    } else {
        kprint("ATA Drive Status: Not Available");
        kprint("Using RAM-based filesystem (ramfs)");
    }
}

static void cmd_format(const char* args) {
    (void)args; // Unused
    
    if (!ata_drive_available()) {
        kprint("Error: No ATA drive available to format");
        return;
    }
    
    // Get actual disk size
    uint32_t total_sectors = ata_get_sector_count();
    uint32_t disk_mb = (total_sectors * 512) / (1024 * 1024);
    uint32_t num_blocks = total_sectors; // 1 sector = 1 block in SimpleFS
    
    char buf[128];
    char temp[32];
    
    kprint("WARNING: This will erase all data on the disk!");
    
    // Build formatting message
    strcpy(buf, "Formatting ");
    itoa(disk_mb, temp, 10);
    strcat(buf, temp);
    strcat(buf, "MB disk with SimpleFS (");
    itoa(num_blocks, temp, 10);
    strcat(buf, temp);
    strcat(buf, " blocks)...");
    kprint(buf);
    
    if (simplefs_format(0, num_blocks) == 0) {
        kprint("Disk formatted successfully.");
        kprint("Reboot to mount the new filesystem.");
    } else {
        kprint("Failed to format disk.");
    }
}

static void cmd_test_disk_write(const char* args) {
    (void)args;
    char buf[32];
    
    kprint("=== Disk Write Test ===");
    
    if (!ata_drive_available()) {
        kprint("Error: No ATA drive available");
        return;
    }
    
    kprint("Step 1: Opening /testfile.txt for writing...");
    int fd = sys_open("/testfile.txt", O_CREAT | O_WRONLY | O_TRUNC);
    if (fd < 0) {
        vga_puts("FAILED: Cannot open file, error=");
        itoa(fd, buf, 10);
        kprint(buf);
        return;
    }
    vga_puts("SUCCESS: File opened, fd=");
    itoa(fd, buf, 10);
    kprint(buf);
    
    kprint("Step 2: Writing 'Hello Disk!' to file...");
    const char* test_data = "Hello Disk!";
    int bytes = sys_write(fd, test_data, strlen(test_data));
    if (bytes < 0) {
        vga_puts("FAILED: Write error=");
        itoa(bytes, buf, 10);
        kprint(buf);
        sys_close(fd);
        return;
    }
    vga_puts("SUCCESS: Wrote ");
    itoa(bytes, buf, 10);
    vga_puts(buf);
    kprint(" bytes");
    
    kprint("Step 3: Closing file...");
    sys_close(fd);
    kprint("SUCCESS: File closed");
    
    kprint("Step 4: Reading back from disk...");
    fd = sys_open("/testfile.txt", O_RDONLY);
    if (fd < 0) {
        vga_puts("FAILED: Cannot reopen file, error=");
        itoa(fd, buf, 10);
        kprint(buf);
        return;
    }
    
    char read_buf[128] = {0};
    bytes = sys_read(fd, read_buf, sizeof(read_buf) - 1);
    if (bytes < 0) {
        vga_puts("FAILED: Read error=");
        itoa(bytes, buf, 10);
        kprint(buf);
        sys_close(fd);
        return;
    }
    
    vga_puts("SUCCESS: Read ");
    itoa(bytes, buf, 10);
    vga_puts(buf);
    kprint(" bytes");
    vga_puts("Content: '");
    vga_puts(read_buf);
    kprint("'");
    
    sys_close(fd);
    
    // Verify content
    if (strcmp(read_buf, test_data) == 0) {
        kprint("=== DISK WRITE TEST PASSED ===");
    } else {
        kprint("=== DISK WRITE TEST FAILED: Data mismatch ===");
    }
}

// User management commands

static void cmd_adduser(const char* args) {
    if (!args || !*args) {
        kprint("Usage: adduser <username> [--admin]");
        return;
    }
    
    // Debug: Check current user status
    session_t* session = user_get_session();
    if (session && session->user) {
        char buf[32];
        serial_puts("Debug: Current user: ");
        serial_puts(session->user->username);
        serial_puts(", UID: ");
        itoa(session->user->uid, buf, 10);
        serial_puts(buf);
        serial_puts(", flags: 0x");
        itoa(session->user->flags, buf, 16);
        serial_puts(buf);
        serial_puts(", is_root: ");
        itoa(user_is_root(), buf, 10);
        serial_puts(buf);
        serial_puts(", is_admin: ");
        itoa(user_is_admin(), buf, 10);
        serial_puts(buf);
        serial_puts("\n");
    }
    
    // Only root can add users
    if (!user_is_root() && !user_is_admin()) {
        kprint("Permission denied: Only root/admin can add users");
        return;
    }
    
    char username[32];
    int is_admin = 0;
    
    // Parse arguments
    const char* ptr = args;
    uint32_t i = 0;
    
    // Extract username (first word)
    while (*ptr && *ptr != ' ' && i < sizeof(username) - 1) {
        username[i++] = *ptr++;
    }
    username[i] = '\0';
    
    // Check for --admin flag
    while (*ptr == ' ') ptr++; // Skip spaces
    if (*ptr && strcmp(ptr, "--admin") == 0) {
        is_admin = 1;
    }
    
    // Create home directory path
    char home_dir[128];
    fs_layout_get_user_home(username, home_dir, sizeof(home_dir));
    
    // Create user with default password (same as username)
    int ret = user_create(username, username, 0, GID_USERS, home_dir, "/bin/shell");
    if (ret == 0) {
        user_t* new_user = user_find_by_name(username);
        if (new_user) {
            // Set admin flag if requested
            if (is_admin) {
                new_user->flags |= USER_FLAG_ADMIN;
                vga_set_color(0x0E); // Yellow
                vga_puts("[ADMIN] ");
                vga_set_color(0x0F); // White
            }
            
            // Force password change on first login
            new_user->flags |= USER_FLAG_MUST_CHANGE_PASS;
        }
        
        // Create home directory
        fs_layout_create_user_home(username);
        
        vga_puts("User '");
        vga_puts(username);
        kprint("' created successfully.");
        kprint("Default password is the same as username.");
        kprint("User will be asked to change password on first login.");
        
        // Save database if in local mode
        if (fs_layout_get_mode() == FS_MODE_LOCAL) {
            user_save_database(USER_DATABASE_PATH);
        }
    } else {
        vga_puts("Failed to create user '");
        vga_puts(username);
        kprint("'");
    }
}

static void cmd_deluser(const char* args) {
    if (!args || !*args) {
        kprint("Usage: deluser <username>");
        return;
    }
    
    // Only root can delete users
    if (!user_is_root() && !user_is_admin()) {
        kprint("Permission denied: Only root/admin can delete users");
        return;
    }
    
    char username[32];
    strncpy(username, args, sizeof(username) - 1);
    username[sizeof(username) - 1] = '\0';
    
    // Remove any trailing spaces
    uint32_t len = strlen(username);
    while (len > 0 && username[len - 1] == ' ') {
        username[--len] = '\0';
    }
    
    int ret = user_delete(username);
    if (ret == 0) {
        vga_puts("User '");
        vga_puts(username);
        kprint("' deleted successfully.");
    } else {
        vga_puts("Failed to delete user '");
        vga_puts(username);
        kprint("'");
    }
}

static void list_user_callback(user_t* user, void* user_data) {
    (void)user_data;
    
    char buf[16];
    
    // Display UID
    vga_puts("  UID ");
    itoa(user->uid, buf, 10);
    vga_puts(buf);
    vga_puts(": ");
    
    // Display username
    vga_puts(user->username);
    
    // Display GID
    vga_puts(" (GID ");
    itoa(user->gid, buf, 10);
    vga_puts(buf);
    vga_puts(")");
    
    // Display status
    if (user->flags & USER_FLAG_LOCKED) {
        vga_puts(" [LOCKED]");
    } else if (!(user->flags & USER_FLAG_ACTIVE)) {
        vga_puts(" [INACTIVE]");
    }
    if (user->flags & USER_FLAG_ADMIN) {
        vga_puts(" [ADMIN]");
    }
    
    kprint("");
}

static void cmd_listusers(const char* args) {
    (void)args;
    
    char buf[16];
    uint32_t count = user_get_count();
    
    vga_puts("Total users: ");
    itoa(count, buf, 10);
    kprint(buf);
    
    if (count > 0) {
        user_list_all(list_user_callback, NULL);
    }
}

static void cmd_passwd(const char* args) {
    session_t* session = user_get_session();
    if (!session || !session->user) {
        kprint("Error: Not logged in");
        return;
    }
    
    (void)args;
    
    char old_password[128];
    char new_password[128];
    char confirm_password[128];
    
    // Get old password
    kprint("Changing password for user: ");
    kprint(session->user->username);
    kprint("");
    vga_puts("Old password: ");
    if (read_password(old_password, sizeof(old_password)) <= 0) {
        kprint("\nPassword change cancelled.");
        return;
    }
    
    // Verify old password
    if (!user_authenticate(session->user->username, old_password)) {
        kprint("\nError: Incorrect password");
        return;
    }
    
    // Get new password
    vga_puts("New password: ");
    if (read_password(new_password, sizeof(new_password)) <= 0) {
        kprint("\nPassword change cancelled.");
        return;
    }
    
    if (strlen(new_password) < 4) {
        kprint("\nError: Password must be at least 4 characters");
        return;
    }
    
    // Confirm new password
    vga_puts("Retype new password: ");
    if (read_password(confirm_password, sizeof(confirm_password)) <= 0) {
        kprint("\nPassword change cancelled.");
        return;
    }
    
    // Check if passwords match
    if (strcmp(new_password, confirm_password) != 0) {
        kprint("\nError: Passwords do not match");
        return;
    }
    
    // Change password
    if (user_change_password(session->user->username, old_password, new_password) == 0) {
        kprint("\nPassword changed successfully!");
        
        // Save to database if in LOCAL mode
        if (fs_layout_get_mode() == FS_MODE_LOCAL) {
            if (user_save_database("/sys/config/users.db") == 0) {
                serial_puts("User database saved after password change\n");
            } else {
                kprint("Warning: Failed to save user database to disk");
            }
        }
    } else {
        kprint("\nError: Failed to change password");
    }
}

static void cmd_fsmode(const char* args) {
    (void)args;
    
    int mode = fs_layout_get_mode();
    vga_puts("Filesystem mode: ");
    if (mode == FS_MODE_LOCAL) {
        kprint("LOCAL (SimpleFS on disk)");
        kprint("  User data will persist across reboots");
    } else {
        kprint("ISO (ramfs in memory)");
        kprint("  User data will NOT persist across reboots");
    }
}

// ===== Process Management Commands (aOS-style) =====

static void cmd_procs(const char* args) {
    (void)args;
    
    kprint("Active Tasks:");
    kprint("TID   STATE     PRIORITY  NAME");
    kprint("----  --------  --------  ----------------");
    
    // Iterate through process table
    for (int i = 0; i < MAX_PROCESSES; i++) {
        process_t* proc = process_get_by_pid(i);
        if (proc && proc->state != PROCESS_DEAD) {
            char line[80];
            char pid_str[8], pri_str[8];
            itoa(proc->pid, pid_str, 10);
            itoa(proc->priority, pri_str, 10);
            
            const char* state_str;
            switch (proc->state) {
                case PROCESS_READY:    state_str = "READY   "; break;
                case PROCESS_RUNNING:  state_str = "RUNNING "; break;
                case PROCESS_BLOCKED:  state_str = "BLOCKED "; break;
                case PROCESS_SLEEPING: state_str = "SLEEPING"; break;
                case PROCESS_ZOMBIE:   state_str = "ZOMBIE  "; break;
                default:               state_str = "UNKNOWN "; break;
            }
            
            strcpy(line, pid_str);
            strcat(line, "     ");
            strcat(line, state_str);
            strcat(line, "  ");
            strcat(line, pri_str);
            strcat(line, "         ");
            strcat(line, proc->name);
            
            kprint(line);
        }
    }
}

static void cmd_terminate(const char* args) {
    if (!args || strlen(args) == 0) {
        kprint("Usage: terminate <task_id>");
        return;
    }
    
    // Parse task ID
    int pid = 0;
    int i = 0;
    while (args[i] >= '0' && args[i] <= '9') {
        pid = pid * 10 + (args[i] - '0');
        i++;
    }
    
    if (pid <= 0) {
        kprint("Error: Invalid task ID");
        return;
    }
    
    process_t* proc = process_get_by_pid(pid);
    if (!proc || proc->state == PROCESS_DEAD) {
        kprint("Error: Task not found");
        return;
    }
    
    if (process_kill(pid, MSG_TERMINATE) == 0) {
        kprint("Task terminated successfully");
    } else {
        kprint("Error: Failed to terminate task");
    }
}

static void cmd_pause(const char* args) {
    if (!args || strlen(args) == 0) {
        kprint("Usage: pause <milliseconds>");
        return;
    }
    
    // Parse milliseconds
    int ms = 0;
    int i = 0;
    while (args[i] >= '0' && args[i] <= '9') {
        ms = ms * 10 + (args[i] - '0');
        i++;
    }
    
    if (ms <= 0) {
        kprint("Error: Invalid duration");
        return;
    }
    
    kprint("Pausing...");
    process_sleep(ms);
    kprint("Resumed");
}

static void cmd_show(const char* args) {
    // Enhanced cat command (aOS style)
    if (!args || strlen(args) == 0) {
        kprint("Usage: show <filename>");
        return;
    }
    
    // Skip leading spaces
    while (*args == ' ') args++;
    
    int fd = sys_open(args, O_RDONLY);
    if (fd < 0) {
        kprint("Error: Cannot open file");
        return;
    }
    
    // Read and display content
    char buffer[256];
    int bytes_read;
    
    while ((bytes_read = sys_read(fd, buffer, sizeof(buffer) - 1)) > 0) {
        buffer[bytes_read] = '\0';
        vga_puts(buffer);
    }
    
    sys_close(fd);
    vga_puts("\n");
}

static void cmd_showmem(const char* args) {
    (void)args;
    
    kprint("Memory Usage:");
    kprint("");
    
    // Physical memory
    uint32_t total_frames = pmm_get_total_frames();
    uint32_t used_frames = pmm_get_used_frames();
    uint32_t free_frames = total_frames - used_frames;
    
    char line[80];
    char num_str[16];
    
    strcpy(line, "Physical: ");
    itoa(used_frames * 4, num_str, 10);
    strcat(line, num_str);
    strcat(line, " KB used, ");
    itoa(free_frames * 4, num_str, 10);
    strcat(line, num_str);
    strcat(line, " KB available");
    kprint(line);
    
    // Kernel heap
    kprint("");
    kprint("Kernel Heap: 2 MB allocated (0x500000 - 0x700000)");
    
    // Process info
    process_t* current = process_get_current();
    if (current) {
        kprint("");
        strcpy(line, "Current Task: ");
        strcat(line, current->name);
        strcat(line, " (TID ");
        itoa(current->pid, num_str, 10);
        strcat(line, num_str);
        strcat(line, ")");
        kprint(line);
    }
}

static void cmd_chanmake(const char* args) {
    (void)args;
    
    int channel_id = channel_create();
    if (channel_id < 0) {
        kprint("Error: Failed to create channel");
        return;
    }
    
    char line[80];
    char id_str[16];
    strcpy(line, "Channel created: ID ");
    itoa(channel_id, id_str, 10);
    strcat(line, id_str);
    kprint(line);
}

static void cmd_chaninfo(const char* args) {
    (void)args;
    kprint("Communication Channels:");
    kprint("Use 'chanmake' to create a new channel");
    kprint("Channels enable inter-task communication");
}

// ===== Partition Management Commands =====

static void cmd_partitions(const char* args) {
    (void)args;
    
    int count = partition_list();
    if (count == 0) {
        kprint("No partitions found");
        return;
    }
    
    kprint("Disk Partitions:");
    kprint("ID  NAME            TYPE    START       SIZE        MOUNT");
    kprint("--  --------------  ------  ----------  ----------  --------");
    
    for (int i = 0; i < count; i++) {
        partition_t* part = partition_get(i);
        if (part) {
            char line[128];
            char id_str[8], start_str[16], size_str[16];
            
            itoa(i, id_str, 10);
            itoa(part->start_sector, start_str, 10);
            itoa(part->sector_count, size_str, 10);
            
            const char* type_str;
            switch (part->type) {
                case PART_TYPE_SYSTEM: type_str = "SYSTEM"; break;
                case PART_TYPE_DATA:   type_str = "DATA  "; break;
                case PART_TYPE_SWAP:   type_str = "SWAP  "; break;
                default:               type_str = "EMPTY "; break;
            }
            
            strcpy(line, id_str);
            strcat(line, "   ");
            strcat(line, part->name);
            strcat(line, "  ");
            strcat(line, type_str);
            strcat(line, "  ");
            strcat(line, start_str);
            strcat(line, "  ");
            strcat(line, size_str);
            strcat(line, "  ");
            if (part->mounted) {
                strcat(line, part->mount_point);
            } else {
                strcat(line, "(unmounted)");
            }
            
            kprint(line);
        }
    }
}

static void cmd_partmount(const char* args) {
    if (!args || strlen(args) == 0) {
        kprint("Usage: partmount <partition_id> <mount_point> <fs_type>");
        return;
    }
    
    // Parse arguments
    int id = 0;
    const char* p = args;
    while (*p >= '0' && *p <= '9') {
        id = id * 10 + (*p - '0');
        p++;
    }
    
    while (*p == ' ') p++;
    const char* mount_point = p;
    while (*p && *p != ' ') p++;
    
    char mount_str[64] = {0};
    strncpy(mount_str, mount_point, p - mount_point);
    
    while (*p == ' ') p++;
    const char* fs_type = p;
    
    if (strlen(mount_str) == 0 || strlen(fs_type) == 0) {
        kprint("Error: Missing arguments");
        return;
    }
    
    if (partition_mount(id, mount_str, fs_type) == 0) {
        kprint("Partition mounted successfully");
    } else {
        kprint("Error: Failed to mount partition");
    }
}

// ===== Environment Variable Commands =====

static void cmd_envars(const char* args) {
    (void)args;
    envar_list();
}

static void cmd_setenv(const char* args) {
    if (!args || strlen(args) == 0) {
        kprint("Usage: setenv <name>=<value>");
        return;
    }
    
    // Find '=' separator
    const char* eq = strchr(args, '=');
    if (!eq) {
        kprint("Error: Use format NAME=VALUE");
        return;
    }
    
    char name[32] = {0};
    char value[128] = {0};
    
    int name_len = eq - args;
    if (name_len >= 32) name_len = 31;
    strncpy(name, args, name_len);
    
    strcpy(value, eq + 1);
    
    if (envar_set(name, value) == 0) {
        kprint("Environment variable set");
    } else {
        kprint("Error: Failed to set variable");
    }
}

static void cmd_getenv(const char* args) {
    if (!args || strlen(args) == 0) {
        kprint("Usage: getenv <name>");
        return;
    }
    
    const char* value = envar_get(args);
    if (value) {
        vga_puts(args);
        vga_puts("=");
        kprint(value);
    } else {
        kprint("Variable not set");
    }
}

// ===== Kernel Module Commands =====

static void cmd_modlist(const char* args) {
    (void)args;
    kmodule_list();
}

static void cmd_modload(const char* args) {
    if (!args || strlen(args) == 0) {
        kprint("Usage: modload <path_to_akm_file>");
        return;
    }
    
    if (kmodule_load(args) == 0) {
        kprint("Module loaded successfully");
    } else {
        kprint("Error: Failed to load module");
    }
}

static void cmd_modunload(const char* args) {
    if (!args || strlen(args) == 0) {
        kprint("Usage: modunload <module_name>");
        return;
    }
    
    if (kmodule_unload(args) == 0) {
        kprint("Module unloaded successfully");
    } else {
        kprint("Error: Failed to unload module");
    }
}

static void cmd_kernelver(const char* args) {
    (void)args;
    
    uint32_t ver = kernel_get_version();
    uint32_t major = (ver >> 16) & 0xFF;
    uint32_t minor = (ver >> 8) & 0xFF;
    uint32_t patch = ver & 0xFF;
    
    char line[64];
    char num_str[8];
    
    strcpy(line, "Kernel version: ");
    itoa(major, num_str, 10);
    strcat(line, num_str);
    strcat(line, ".");
    itoa(minor, num_str, 10);
    strcat(line, num_str);
    strcat(line, ".");
    itoa(patch, num_str, 10);
    strcat(line, num_str);
    
    kprint(line);
    kprint("Module format: .akm (aOS Kernel Module)");
}

// ===== File Editor Command =====

#include <editor.h>

static void cmd_edit(const char* args) {
    if (!args || !*args) {
        kprint("Usage: edit <filename>");
        kprint("Opens a nano-like text editor for file editing");
        return;
    }
    
    // Create editor context
    editor_context_t editor;
    editor_init(&editor);
    
    // Try to open existing file, or create new one
    int ret = editor_open_file(&editor, args);
    if (ret < 0) {
        // File doesn't exist, create new
        editor_new_file(&editor, args);
    }
    
    // Run editor
    editor_run(&editor);
    
    // Cleanup
    editor_cleanup(&editor);
    
    vga_set_color(0x0F);
}

// Command registry
static const command_t commands[] = {
    {"help", "", "Display all available commands with descriptions", cmd_help},
    {"mem", "", "Display total system memory information", cmd_mem},
    {"vmm", "", "Display virtual memory manager status and statistics", cmd_vmm},
    {"test-page", "", "Test physical page allocation and deallocation", cmd_test_page},
    {"test-fs", "", "Test VFS and ramfs operations (create, read, write)", cmd_test_fs},
    {"clear", "", "Clear the screen and reset cursor position", cmd_clear},
    {"version", "", "Display operating system version information", cmd_version},
    {"reboot", "", "Reboot the system immediately", cmd_reboot},
    {"halt", "", "Halt the system (stop all execution)", cmd_halt},
    {"shutdown", "", "Power off the system (works on QEMU and compatible hypervisors)", cmd_poweroff},
    {"echo", "<text>", "Echo the provided text to the screen", cmd_echo},
    {"uptime", "", "Display system uptime in hours, minutes, and seconds", cmd_uptime},
    // Filesystem commands
    {"lst", "[path]", "List directory contents (default: current directory /)", cmd_lst},
    {"show", "<filename>", "Display file contents (enhanced view)", cmd_show},
    {"view", "<filename>", "Display file contents", cmd_view},
    {"edit", "<filename>", "Open text editor to edit file", cmd_edit},
    {"create", "<filename> [--empty]", "Create a new file (use --empty for touch behavior)", cmd_create},
    {"write", "<filename> <content>", "Write content to a file (overwrites existing)", cmd_write},
    {"rm", "[--force] <file|directory>", "Remove a file or directory (use --force for non-empty dirs)", cmd_rm},
    {"mkfld", "<dirname>", "Create a new directory/folder", cmd_mkfld},
    {"go", "<directory>", "Change current working directory (equivalent to cd)", cmd_go},
    {"pwd", "", "Print current working directory", cmd_pwd},
    {"disk-info", "", "Display disk and filesystem information", cmd_disk_info},
    {"format", "", "Format the disk with SimpleFS (WARNING: erases all data)", cmd_format},
    {"test-disk", "", "Test disk write and read operations with detailed logging", cmd_test_disk_write},
    // Process/Task management commands (aOS-style)
    {"procs", "", "List all active tasks with status", cmd_procs},
    {"terminate", "<task_id>", "Terminate a task by ID", cmd_terminate},
    {"pause", "<milliseconds>", "Pause execution for specified milliseconds", cmd_pause},
    {"showmem", "", "Display memory usage statistics", cmd_showmem},
    // IPC commands
    {"chanmake", "", "Create a new communication channel", cmd_chanmake},
    {"chaninfo", "", "Display information about communication channels", cmd_chaninfo},
    // Partition management commands
    {"partitions", "", "List all disk partitions", cmd_partitions},
    {"partmount", "<id> <path> <fs>", "Mount a partition to mount point", cmd_partmount},
    // Environment variable commands
    {"envars", "", "List all environment variables", cmd_envars},
    {"setenv", "<name>=<value>", "Set an environment variable", cmd_setenv},
    {"getenv", "<name>", "Get environment variable value", cmd_getenv},
    // Kernel module commands
    {"modlist", "", "List loaded kernel modules", cmd_modlist},
    {"modload", "<path>", "Load kernel module (.akm file)", cmd_modload},
    {"modunload", "<name>", "Unload kernel module", cmd_modunload},
    {"kernelver", "", "Show kernel version info", cmd_kernelver},
    // User management commands
    {"adduser", "<username> [--admin]", "Create a new user account (admin only)", cmd_adduser},
    {"deluser", "<username>", "Delete a user account (admin only)", cmd_deluser},
    {"listusers", "", "List all user accounts", cmd_listusers},
    {"passwd", "", "Change current user password (interactive)", cmd_passwd},
    {"fsmode", "", "Display current filesystem mode (ISO vs LOCAL)", cmd_fsmode},
};

static const uint32_t num_commands = sizeof(commands) / sizeof(command_t);

void init_commands(void) {
    // Currently no initialization needed
    // Could be used in future for dynamic command registration
}

void execute_command(const char* input) {
    if (!input || *input == '\0') {
        return; // Empty command
    }
    
    // Find the first space to separate command from arguments
    const char* space = input;
    while (*space && *space != ' ') {
        space++;
    }
    
    // Calculate command name length
    uint32_t cmd_len = space - input;
    
    // Skip spaces to find arguments
    const char* args = space;
    while (*args && *args == ' ') {
        args++;
    }
    
    // If no arguments found, set to NULL
    if (*args == '\0') {
        args = NULL;
    }
    
    // Search for command
    for (uint32_t i = 0; i < num_commands; i++) {
        uint32_t name_len = 0;
        const char* name = commands[i].name;
        while (name[name_len]) name_len++;
        
        if (cmd_len == name_len && strncmp(input, name, cmd_len) == 0) {
            // Command found, execute handler
            commands[i].handler(args);
            return;
        }
    }
    
    // Command not found
    vga_puts("Command not found: ");
    
    // Print only the command name, not the arguments
    char temp_buf[64];
    uint32_t copy_len = cmd_len < 63 ? cmd_len : 63;
    for (uint32_t i = 0; i < copy_len; i++) {
        temp_buf[i] = input[i];
    }
    temp_buf[copy_len] = '\0';
    kprint(temp_buf);
}
